layout: true
class: basic, layout, imaging, fonts, lists, cards, fadein, tabler
name: content
<div class="basic header"></div>
<div class="basic footer"><p>CS2030S: Programming Methodology II -- Adi Yoga S. Prabawa</p></div>

---

name: Lecture_03
class: bottom, titles

# CS2030S
## Programming Methodology II
### Lecture 03: Polymorphism

---

name: Announcement
class: middle, sections

# Announcement

---

# Announcement

.ft15.subsections[
### Lab/Recitation
]
.ft82[
## Lab/Recitation

.card.bg-y[
### Lab Session
.content.tight[
- Starts this week
- Lab 1 will open this Thursday
    - Deadline is next Tuesday
- Please email me if you have not submitted your Github username survey
    - I will reopen the survey for you
]
]

.card.bg-y[
### Recitation Session
.content.tight[
- Starts this week
- Problem Set 1 is uploaded
    - No need to submit but do prepare before coming to session
]
]
]

---

# Announcement

.ft15.subsections[
### Lab/Recitation
### Lab Vacancies
]
.ft82[
## Lab/Recitation

.card.bg-r[
### Lab Vacancies
.content.tight[
We would like to request people from Lab 14A and Lab 14B to move if they have no clash with other sessions to accommodate those who can only attend Lab 14A or Lab 14B.

<br>

Do email me if you want to voluntarily swap from Lab 14A or Lab 14B.  Put the subject as `[CS2030S] Lab Swap`.
]
]

.card.bg-b[
### Lab Adjustment
.content.tight[
We may also move you from Lab XXA to Lab XXB .note16[(and vice versa)] to balance the workload of the TA.

<br>

Do email me if you want to voluntarily move from Lab XXA to Lab XXB.  Put the subject as `[CS2030S] Lab Move`.
]
]
]

---

# Announcement

.ft15.subsections[
### Lab/Recitation
### Lab Vacancies
### Catch-Up Session
]
.ft82[
## Catch-Up Session

.card.bg-y[
### Catch-Up Session #1
.content.tight[
- This Saturday, 10:00
- On Zoom, the link will be announced later
    - Session will be recorded
- Q&A Session
    - You may ask your questions beforehand .note16[(the link will be announced later as well)]
    - Please come to clarify your questions .note16[(if needed)]
    - As usual, Q&A will be transferred to Piazza
]
]
]

---

name: Recap
class: middle, sections

# Recap

---

# Recap

.ft15.subsections[
### Class Design
]
.ft82[
## Class Design
### Composition & Inheritance
.col51[
.card.bg-g[
### Composition
.content.tight[
A __composition__ captures a _".uline[has a]"_ relationship
]
]

```java
class Circle {
  private Point c;
  // other code omitted
}
```

.card.bg-y[
### Note
.content.tight[
All _public_ methods of `Point` can be called with `c.method(..)` from inside the class `Circle` .note16[(i.e., need to be manually invoked)].
]
]
]
.ft49[
.card.bg-g[
### Inheritance
.content.tight[
An __inheritance__ captures an _".uline[is a]"_ relationship
]
]

```java
class ColouredCircle extends Circle {
  private String colour;
  // other code omitted
}
```

.card.bg-y[
### Note
.content.tight[
All _public_ methods of `Circle` can be called with `this.method(..)` from inside the class `ColouredCircle` .note16[(i.e., automatically inherited)].
]
]
]
]

---

# Recap

.ft15.subsections[
### Class Design
### Method Summary
]
.ft82[
## Method Summary
### Signature & Descriptor
.col51[
.card.bg-b[
### Method Signature
.content.tight[
A __method signature__ includes:
1. The method name
2. The type of arguments
3. The order of arguments
4. The number of arguments
]
]
]
.ft49[
.card.bg-b[
### Method Descriptor
.content.tight[
A __method descriptor__ is the __method signature__ + the return type.
]
]
]
]

.ft82[
#### Steps
.col50[
```java
public boolean contains(int x, int y) {
    :
}
```
]
.ft50[
1. Remove body, modifiers, and parameter name .note16[(method descriptor)]
```java[copy=nones]
boolean contains(int, int)
```
2. Remove return type .note16[(method signature)]
```java[copy=nones|show=2]
boolean
contains(int, int)
```
]
]

---

# Recap

.ft15.subsections[
### Class Design
### Method Summary
### Method Override
]
.ft82[
## Method Override

.card.bg-b[
### Definition
.content.tight[
__Method overriding__ happens when a subclass defines an _instance method_ with the __same method descriptor__ .note16[(as an exception, the overriding method can return the subclass)] as an instance method in the superclass.

<br>

As a good practice, when overriding an instance method in superclass, annotate the method in the subclass with `@Override` annotation.
]
]

#### Example
.col63[
```java
class Circle {
  private Point c;
  private double r;
  
  @Override
  public String toString() {
    return "Circle(" + this.c + ", " + this.r + ")";
  }
}
```
]
.ft37[
.card.bg-y[
### Note
.content.tight[
`toString()` method is automatically called when printing .note16[(i.e., `System.out.println(..)`)] or concatenating with `String` using `+` operator.

<br>

This automatic conversion is not done when assigning to a `String`.
]
]
]
]

---

name: Polymorphism
class: middle, sections

# Polymorphism

---

# Polymorphism

.ft15.subsections[
### Method Overloading
#### Definition
]
.ft82[
## Method Overloading
.card.bg-b[
### Definition
.content.tight[
__Method overloading__ happens when we have _two or more_ methods in the same class .note16[(or inherited from superclass)] with the same name but different _method signature_.

<br>

We cannot overload a method by changing its return type .note16[(i.e., not looking at method descriptor)].
]
]

#### Example
.col63[
```java
class Circle {
    :
  public boolean contains(Point p) {
    // code omitted
  }
  
  public boolean contains(double x, double y) {
    // code omitted
  }
}
```
]
.ft37[
.card.bg-y[
### Note
.content.tight[
We can see the overloading by looking at the method signature:
- `contains(Point)`
- `contains(double, double)`
]
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
#### Definition
#### Quiz
]
.ft82[
## Method Overloading
### Quiz

.qns[
> ##### Question
> Assume we have three classes `A`, `B`, and `C` and consider the method below.
```java
C f(A x, B y) { /* .. */ }
```
> Select ALL the methods that are overloading the method above.
>
> __Hint:__ first determine the method signature.
]

.mrq[
1. .quiz-choice[.font20[`C f(A a, B b)`]] .quiz-ans[0] .quiz-hint[NO: same signature `f(A, B)`]
2. .quiz-choice[.font20[`A f(B x, C y)`]] .quiz-ans[1] .quiz-hint[YES: different signature `f(B, C)`]
1. .quiz-choice[.font20[`A f(A x, B y)`]] .quiz-ans[0] .quiz-hint[NO: still same signature `f(A, B)`]
2. .quiz-choice[.font20[`C f(B x, A y)`]] .quiz-ans[1] .quiz-hint[YES: different signature `f(B, A)`]

.quizzes-poll[OEsuB9bkTdD2n1A7jTa3p]
.quizzes-time[60]
.quizzes-qr[https://www.comp.nus.edu.sg/~adi-yoga/remark/img/QR.png]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
#### Motivation
]
.ft82[
## Polymorphism
### Motivation
```java
void say(Object obj) {
  System.out.println("Hi, I am " + obj.toString());
}
```

#### Problems?
- All classes is a subclass .note16[(directly or indirectly)] of `Object`
    - `Object` has the method `Object::toString()`
    - All classes inherits `Object::toString()`
- The behaviour of `Object::toString()` is fixed
    - Do we need overloaded `say` method for different classes?
    - How do we change the behaviour of `say` without modifying or overloading `say`?
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
#### Motivation
]
.ft82[
## Polymorphism
### Motivation
```java
void say(Object obj) {
  System.out.println("Hi, I am " + obj.toString());
}
```

#### Without Polymorphism
.col62[
```java
void say(Object obj) {
  if (obj instanceof Circle) {
    Circle c = (Circle) obj;
    System.out.println("Hi, I am " + c.toString());
  } else if (obj instanceof Point) {
    Point p = (Point) obj;
    System.out.println("Hi, I am " + p.toString());
  }
    :
}
```
]
.ft38[
.card.bg-y[
### Note
.content.tight[
- `obj instanceof Circle` operator checks if the run-time type of `obj` is a subtype of `Circle`.
- `Circle c = (Circle) obj` explicitly type casted `obj` to type `Circle`.
- If we want to include more types, we need to add more `else if`.
]
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
#### Motivation
]
.ft82[
## Polymorphism
### Motivation
```java
void say(Object obj) {
  System.out.println("Hi, I am " + obj.toString());
}
```

#### With Polymorphism
.col51[
```jshell
jshell> Point p = new Point(0, 0)
p ==> Point(0.0, 0.0)

jshell> say (p)
Hi, I am Point(0.0, 0.0)

jshell> Circle c = new Circle(p, 3)
c ==> Circle(Point(0.0, 0.0), 3.0)

jshell> say(c)
Hi, I am Circle(Point(0.0, 0.0), 3.0)
```
]
.ft49[
.card.bg-y[
### Advantage
.content.tight[
_"Polymorphism enables you to write programs that process objects that share the same superclass __as if they're all objects of that superclass__"_

<br>

.right[Deitel & Deitel]
]
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
#### Motivation
#### equals
]
.ft82[
## Polymorphism
### Object::equals(Object obj)
<iframe src="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" width="950" height="450" frameborder="0"> </iframe>
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
#### Motivation
#### equals
]
.ft82[
## Polymorphism
### Object::equals(Object obj)
.col65[
```jshell[lite=11]
jshell> Circle c1 = new Circle(new Point(0, 0), 10)
c1 ==> Circle(Point(0.0, 0.0), 10.0)

jshell> Circle c2 = new Circle(new Point(0, 0), 10)
c2 ==> Circle(Point(0.0, 0.0), 10.0)

jshell> c1 == c2
$10 ==> false

jshell> c1.equals(c2)
$11 ==> false
```
]
.ft35[
#### Stack/Heap Diagram
![Stack Heap](img/03-equals.png)
]
]

.ft82[
.card.bg-y[
### Note
.content.tight[
The `==` operator compares _references_ .note16[(i.e., checking if the two variables are pointing to the same object)] and not checking the _semantics_ of a `Circle`.
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
#### Motivation
#### equals
#### Overloading
]
.ft82[
## Polymorphism
### via Overloading
.col65[
```java
class Circle {
  // code omitted
  public boolean equals(Circle circle) {
      return (circle.c.equals(this.c))
          && (circle.r == this.r);
  }
}
```

#### Testing
```jshell[lite=2|steps=1;1-2]
jshell> c1.equals(c2)
$11 ==> false
```
]
.ft35[
![Huh?](https://c.tenor.com/bygKq3UlHYUAAAAd/what-nick-young.gif)

.card.bg-y[
### Why?
.content.tight[
We have not implemented `equals` for `Point`.
]
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
#### Motivation
#### equals
#### Overloading
]
.ft82[
## Polymorphism
### via Overloading
.col65[
```java
class Point {
  // code omitted
  public boolean equals(Point point) {
      return (point.x == this.x)
          && (point.y == this.y);
  }
}
```

#### Testing
```jshell[lite=5|steps=1,2,4;1-5]
jshell> Object obj = c1;
jshell> obj == c1;
true
jshell> obj.equals(c2);
false
```
]
.ft35[
![Huh?](https://c.tenor.com/bygKq3UlHYUAAAAd/what-nick-young.gif)

.card.bg-y[
### Why?
.content.tight[
The mechanism to choose which method to be invoked is called __dynamic binding__, we will discuss that later.
]
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
#### Motivation
#### equals
#### Overloading
#### Overriding
]
.ft82[
## Polymorphism
### via Overriding
.col65[
```java
class Circle {
  // code omitted
  @Override
  public boolean equals(Object obj) {
    if (obj instanceof Circle) {
      Circle circle = (Circle) obj; // unavoidable
      return (circle.c.equals(this.c))
          && (circle.r == this.r);
    }
    return false;
  }
}
```
]
.ft35[
#### Testing
```jshell[lite=2]
jshell> c1.equals(c2)
$11 ==> true
```

.card.bg-y[
### Note
.content.tight[
We have to perform explicit type cast here because `Object` class has no field called `x` and `y`;
]
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
#### Definition
]
.ft82[
## Dynamic Binding
.card.bg-b[
### Definition
.content.tight[
The __dynamic binding__ mechanism is a mechanism to determine which _instance method_ to be invoked according to the _run-time type_ of the target of invocation .note16[(i.e., the run-time type of `obj` in the expression `obj.method(..)`)].

<br>

Dynamic binding is two-part process.
1. __Compile-Time Part__
    - Determine the method descriptor to be invoked.
2. __Run-Time Part__
    - Determine the method implementation based on the retrieved method descriptor in part 1.
]
]

.col51[
.card.bg-y[
### Note
.content.tight[
This is best visualised using class diagram.
]
]
]
.ft49[
.card.bg-r[
### Static Binding
.content.tight[
Dynamic binding is only used for .uline[_instance methods_].
Class methods as well as both class fields and instance fields are not resolved using dynamic binding.
]
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
#### Definition
#### Compile-Time Part
]
.ft82[
## Dynamic Binding
### Compile-Time Part

```java[copy=nones]
obj.foo(arg);
```

#### Steps
.col75[
1. Determine the .uline[_compile-time type_] ___T___ of `obj`.
2. Collect all methods accessible in class ___T___ with the name `foo`<br>.note16[(includes methods signature in superclasses of ___T___)].
    - If there are none, then it is an error.
3. Keep only methods from step 2 that can accept the .uline[_compile-time type_] of `arg`<br>.note16[(if there are more than 1 arguments, it must be able to accept all)].
    - If there are none, then it is an error.
4. Find the .uline[_most specific method descriptor_] from step 3.
    - If there are more than one, then it is an error.
    - The method descriptor is to be used in Run-Time Part.
]
.ft25[
.card.bg-y[
### Most Specific
.content.tight[
A method ___M___ is _more specific_ than method ___N___ if the arguments to ___M___ can be passed to ___N___ without compilation error but not the other way around.
]
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
#### Definition
#### Compile-Time Part
#### Run-Time Part
]
.ft82[
## Dynamic Binding
### Run-Time Part

```java[copy=nones]
obj.foo(arg);
```

#### Steps
.col75[
1. Retrieve the .uline[_method descriptor_] found in Compile-Time Part.
2. Determine the .uline[_run-time type_] ___T___ of `obj`.
3. Starting from class ___T___, select the .uline[_nearest_] method implementation with matching .uline[_method descriptor_] in the class hierarchy.
    1. Start from type ___T___.
    2. If found, execute this method implementation.
    3. If not found, continue searching from the superclass of ___T___.
]
.ft25[
.card.bg-y[
### Note
.content.tight[
Normally, the run-time part will not cause any error because Java ensure type safety.
But if the method is not found in step 3 above, then a run-time error will occur.
]
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
#### Definition
#### Compile-Time Part
#### Run-Time Part
#### Example #1
]
.abs.lt70.wt20.top2[
![Example1](img/03-DynamicBinding01.png)
]
.ft82[
## Dynamic Binding
### Example #1
Which method is invoked by the following code?

```java
Circle c1 = new Circle(new Point(0, 0), 1);
Circle c2 = new Circle(new Point(0, 0), 1);
c1.equals(c2);
```

#### Compile-Time Part
1. Accessible methods named `equals` from compile-time type of `c1`?
.nol[
- <input type="text" class="remark-live-input">
]
2. Compatible methods that can accept compile-time type of `c2`?
.nol[
- <input type="text" class="remark-live-input">
]
3. Most specific method?
.nol[
- <input type="text" class="remark-live-input">
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
#### Definition
#### Compile-Time Part
#### Run-Time Part
#### Example #1
]
.abs.lt70.wt20.top2[
![Example1](img/03-DynamicBinding01.png)
]
.ft82[
## Dynamic Binding
### Example #1
Which method is invoked by the following code?

```java
Circle c1 = new Circle(new Point(0, 0), 1);
Circle c2 = new Circle(new Point(0, 0), 1);
c1.equals(c2);
```

#### Run-Time Part
1. Required method descriptor?
.nol[
- <input type="text" class="remark-live-input">
]
2. Nearest method from run-time type of `c1`?
.nol[
- <input type="text" class="remark-live-input">
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
#### Definition
#### Compile-Time Part
#### Run-Time Part
#### Example #1
#### Example #2
]
.abs.lt70.wt20.top2[
![Example1](img/03-DynamicBinding01.png)
]
.ft82[
## Dynamic Binding
### Example #2
Which method is invoked by the following code?

```java[lite=2]
Circle c1 = new Circle(new Point(0, 0), 1);
Object c2 = new Circle(new Point(0, 0), 1);
c1.equals(c2);
```

#### Compile-Time Part
1. Accessible methods named `equals` from compile-time type of `c1`?
.nol[
- <input type="text" class="remark-live-input">
]
2. Compatible methods that can accept compile-time type of `c2`?
.nol[
- <input type="text" class="remark-live-input">
]
3. Most specific method?
.nol[
- <input type="text" class="remark-live-input">
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
#### Definition
#### Compile-Time Part
#### Run-Time Part
#### Example #1
#### Example #2
]
.abs.lt70.wt20.top2[
![Example1](img/03-DynamicBinding01.png)
]
.ft82[
## Dynamic Binding
### Example #2
Which method is invoked by the following code?

```java[lite=2]
Circle c1 = new Circle(new Point(0, 0), 1);
Object c2 = new Circle(new Point(0, 0), 1);
c1.equals(c2);
```

#### Run-Time Part
1. Required method descriptor?
.nol[
- <input type="text" class="remark-live-input">
]
2. Nearest method from run-time type of `c1`?
.nol[
- <input type="text" class="remark-live-input">
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
#### Definition
#### Compile-Time Part
#### Run-Time Part
#### Example #1
#### Example #2
#### Quiz #1
]
.ft82[
## Dynamic Binding
### Quiz #1

.col55[
.qns[
> ##### Question
> Consider the class definition on the right. Which method is invoked by the following code?
```java
C obj = new C();
C arg = new C();
obj.foo(arg);
```
]
]
.ft45[
#### Code
```java
class A { }
class B extends A {
  public void foo(B b) { }
}
class C extends B {
  public void foo(A a) { }
}
```
]

.mrq[
1. .quiz-choice[.font20[`B::foo(B)`]] .quiz-ans[1] .quiz-hint[YES: more specific (although farther in hierarchy)]
2. .quiz-choice[.font20[`C::foo(A)`]] .quiz-ans[0] .quiz-hint[NO: less specific (although nearer in hierarchy)]
1. .quiz-choice[Error] .quiz-ans[0] .quiz-hint[NO: we found a method]

.quizzes-poll[qCkMbx64knWzNSWhuRZfH]
.quizzes-time[30]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
#### Definition
#### Compile-Time Part
#### Run-Time Part
#### Example #1
#### Example #2
#### Quiz #1
#### Quiz #2
]
.ft82[
## Dynamic Binding
### Quiz #2

.col55[
.qns[
> ##### Question
> Consider the class definition on the right. Which method is invoked by the following code?
```java
B obj = new C();
A arg = new C();
obj.foo(arg);
```
]
]
.ft45[
#### Code
```java
class A { }
class B extends A {
  public void foo(B b) { }
}
class C extends B {
  public void foo(A a) { }
}
```
]

.mrq[
1. .quiz-choice[.font20[`B::foo(B)`]] .quiz-ans[0] .quiz-hint[NO: no match for `foo(A)` in class `B` or its superclasses]
2. .quiz-choice[.font20[`C::foo(A)`]] .quiz-ans[0] .quiz-hint[NO: already compilation error]
1. .quiz-choice[Error] .quiz-ans[1] .quiz-hint[YES: no method found]

.quizzes-poll[P5WYiQylPxS5nwQBG5BV8]
.quizzes-time[30]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
### Liskov
#### Definition
]
.ft82[
## Liskov Substitution Principle
.card.bg-b[
### Definition
.content.tight[
The __Liskov substitution principle__ .note16[(abbreviated LSP)] states

<br>

.nol[
- Let ___ϕ(x)___ be a property provable about objects `x` of type ___T___. Then ___ϕ(y)___ should be true for objects `y` of type ___S___ where ___S <: T___.
]

<br>

In other words,

<br>

.nol[
- If ___S___ is a subclass of ___T___, then an object of type ___T___ can be replaced by that of type ___S___ without changing the .uline[_desirable property_] of the program.
]

<br>

In plain terms,

<br>

.nol[
- A .uline[_subclass_] should not break the expectations set by the .uline[_superclass_].
]
]
]

.card.bg-y[
### Desirable Property
.content.tight[
Desirable property may come from (i) test cases, (ii) specification .note16[(usually in English)], (iii) a given code, .note16[etc].
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
### Liskov
#### Definition
#### Example
]
.ft82[
## Liskov Substitution Principle
### Example
#### Code
.col53[
```java
void displayGrade(Module m, double marks) {
  char grade = m.marksToGrade(marks);
  if (grade == 'A') {
    System.out.println("well done!");
  } else if (grade == 'B') {
    System.out.println("good");
  } else if (grade == 'C') {
    System.out.println("okay");
  } else {
    System.out.println("please try again");
  }
}
```
]
.ft47[
.card.bg-y[
### Specification
.content.tight[
`Module::marksToGrade(double)` should return one of the following: `A`, `B`, `C`, or `F`.
]
]

```java
class CSCUMod extends Module {
  public char marksToGrade(double mark) {
    if (mark > 50) {
      return 'S';
    } else {
      return 'U';
    }
  }
}
```
]
]
.abs.lt70.wt28.top2[
.card.bg-r[
### Quick Quiz
.content.tight[
Does `CSCUMod` violates LSP?
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
### Liskov
### Prevention
#### final
]
.ft82[
## Inheritance Prevention
### final Keyword

```java
public final class Point { // the class cannot be inherited
  private final double x;  // field x cannot be re-assigned
  private final double y;  //   i.e., set once and never again
  
  @Override
  public final String toString() { // cannot be overridden in subclass
    return "Point(" + this.x + ", " + this.y + ")";
  }
}
```

.card.bg-y[
### Note
.content.tight[
In the above example, `Point` cannot be inherited so automatically `toString` cannot be overridden because there is no subclass.
In this case, the keyword `final` in `Point::toString()` serves no purpose.

<br>

It is useful if the class is not declared with modifier `final`.
]
]
]

---

name: Abstract_Class
class: middle, sections

# Abstract Class

---

# Abstract Class

.ft15.subsections[
### Motivation
#### Initial
]
.ft82[
## Motivation
### Initial
.col51[
#### Class Diagram
![Circle](img/03-Circle.png)
]
.ft49[
#### Usage
```java
double findLargest(Circle[] array) {
  double maxArea = 0;
  for (Circle curr : array) {
    double area = curr.getArea();
    if (area > maxArea) {
      maxArea = area;
    }
  }
  return maxArea;
}
```
]
]

---

# Abstract Class

.ft15.subsections[
### Motivation
#### Initial
#### Generalization
]
.ft82[
## Motivation
### Generalization
.col51[
#### Class Diagram
![Square](img/03-Square.png)
]
.ft49[
#### Usage
```java[lite=1,3]
double findLargest(??????[] array) {
  double maxArea = 0;
  for (?????? curr : array) {
    double area = curr.getArea();
    if (area > maxArea) {
      maxArea = area;
    }
  }
  return maxArea;
}
```
]
]
.abs.lt70.wt28.top2[
.card.bg-r[
### Quick Quiz
.content.tight[
What should be the type in `??????` such that we can accept both `Circle` and `Square` as well as invoking `curr.getArea()`?
]
]
]

---

# Abstract Class

.ft15.subsections[
### Motivation
#### Initial
#### Generalization
#### Problem #1
]
.ft82[
## Motivation
### Problem #1
.col51[
#### Class Diagram
![Square](img/03-Square.png)
]
.ft49[
#### Usage
```java[lite=4]
double findLargest(Object[] array) {
  double maxArea = 0;
  for (Object curr : array) {
    double area = curr.getArea();
    if (area > maxArea) {
      maxArea = area;
    }
  }
  return maxArea;
}
```

.card.bg-r[
### Problem #1
.content.tight[
The class `Object` has no `getArea()` method.
]
]
]
]

---

# Abstract Class

.ft15.subsections[
### Motivation
#### Initial
#### Generalization
#### Problem #1
#### Problem #2
]
.ft82[
## Motivation
### Problem #2
.col51[
#### Class Diagram
![Shape](img/03-Shape.png)
]
.ft49[
#### Usage
```java[lite=4]
double findLargest(Object[] array) {
  double maxArea = 0;
  for (Object curr : array) {
    double area = curr.getArea();
    if (area > maxArea) {
      maxArea = area;
    }
  }
  return maxArea;
}
```

.card.bg-r[
### Problem #2
.content.tight[
What is the "area" of an arbitrary shape?
]
]
]
]

---

# Abstract Class

.ft15.subsections[
### Motivation
### Abstract Class
#### Definition
]
.ft82[
## Abstract Class
.card.bg-b[
### Definition
.content.tight[
An __abstract class__ is a class that cannot be _instantiated_.
It typically represents an abstract concept .note16[(i.e., not concrete, so instantiating it is "unphysical")].

<br>

#### Properties
- Abstract class can be subclasses.
- Abstract class may have fields.
- Abstract class may have abstract methods .note16[(i.e., method without implementation)].
- Abstract class may have non-abstract methods .note16[(i.e., concrete methods)].
- Abstract class is not required to have abstract methods.
- If a class has an abstract method, it must be declared abstract.
]
]

#### Example
```java
abstract class Shape {              // abstract class
  public abstract double getArea(); // abstract method: no implementation
}
```
]

---

# Abstract Class

.ft15.subsections[
### Motivation
### Abstract Class
#### Definition
#### Solution
]
.ft82[
## Abstract Class
### Solution
.col51[
#### Class Diagram
![Abstract](img/03-Abstract.png)
]
.ft49[
#### Usage
```java[lite=4]
double findLargest(Shape[] array) {
  double maxArea = 0;
  for (Shape curr : array) {
    double area = curr.getArea();
    if (area > maxArea) {
      maxArea = area;
    }
  }
  return maxArea;
}
```

.card.bg-y[
### Note
.content.tight[
`new Shape()` gives a compilation error.
]
]
]
]

---

layout: false
class: middle, end, fadein

`jshell> /exit`

`|  Goodbye`